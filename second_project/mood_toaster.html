<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Don't Drop the Invisible Ball üèê (Audio-only)</title>
<style>
  body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; background: linear-gradient(180deg,#0f1226,#121827); color:#e6eef8; margin:0; display:flex; align-items:center; justify-content:center; height:100vh; }
  .wrap { width:900px; max-width:95vw; background: linear-gradient(180deg,#0b1220,#0f1b2a); padding:18px; border-radius:12px; box-shadow: 0 10px 40px rgba(2,5,10,0.6); }
  h1 { margin:0 0 10px; font-size:20px; text-align:center; }
  .row { display:flex; gap:10px; align-items:center; justify-content:center; margin-bottom:10px; flex-wrap:wrap; }
  button { padding:10px 14px; border-radius:8px; border:none; cursor:pointer; background:#ffd166; color:#0b1020; font-weight:700; }
  button.secondary { background:#8ecae6; color:#052; }
  canvas { display:block; background: linear-gradient(180deg,#071022,#092033); border-radius:8px; margin:0 auto; box-shadow: 0 6px 18px rgba(0,0,0,0.6); }
  .instructions { font-size:13px; color:#a7b6cf; text-align:center; margin-bottom:8px; }
  .stats { display:flex; gap:12px; justify-content:center; color:#cfe9ff; font-weight:600; margin-top:10px; }
  .mutebtn { background:#ffe6e6; color:#3a0b0b; }
  .cheat { background:#bde0fe; color:#012; }
  footer { font-size:12px; color:#93a6c5; text-align:center; margin-top:8px;}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Don‚Äôt Drop the Invisible Ball üèê ‚Äî Audio Only</h1>

    <div class="row instructions">
      Move the paddle (mouse or touch) left/right. The *ball is invisible* ‚Äî listen for pings:
      left/right panning = horizontal position, pitch/volume = vertical distance (higher pitch/volume = closer).
    </div>

    <div class="row">
      <button id="startBtn">Start</button>
      <button id="pauseBtn" class="secondary">Pause</button>
      <button id="muteBtn" class="mutebtn">Mute</button>
      <button id="revealBtn" class="cheat">Peek (cheat)</button>
      <label style="color:#9fb4d6;">
        Difficulty:
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
      </label>
    </div>

    <canvas id="game" width="860" height="420"></canvas>

    <div class="stats">
      <div>Score: <span id="score">0</span></div>
      <div>Lives: <span id="lives">3</span></div>
      <div>Bounces: <span id="bounces">0</span></div>
      <div>Round: <span id="round">1</span></div>
    </div>

    <footer>
      Tip: listen for the ping every ~300ms. Pan (left/right) tells horizontal ‚Äî pitch tells vertical. If you catch it (paddle hit), you'll hear a pop.
    </footer>
  </div>

<script>
/* Invisible Ball ‚Äî Audio-only game
   - Uses WebAudio for pings, pops, and spatial hints
   - Player controls paddle left/right with mouse/touch
   - Ball is invisible; rely on audio cues
*/

// Canvas & UI
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const muteBtn = document.getElementById('muteBtn');
const revealBtn = document.getElementById('revealBtn');
const difficultyEl = document.getElementById('difficulty');

const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const bouncesEl = document.getElementById('bounces');
const roundEl = document.getElementById('round');

let audioCtx = null; // created on first user interaction
let pingIntervalId = null;
let muted = false;
let running = false;
let reveal = false;

// Game state
let score = 0;
let lives = 3;
let bounces = 0;
let round = 1;

// Dimensions
const W = canvas.width, H = canvas.height;
const groundY = H - 40;

// Paddle
const paddle = {
  w: 160,
  h: 14,
  x: W/2 - 80,
  y: groundY - 6
};

// Invisible ball (physics)
let ball = {
  x: W/2,
  y: 80,
  vx: 160, // px/sec
  vy: 40,
  r: 12,
  gravity: 600
};

// Difficulty settings
function applyDifficulty() {
  const d = difficultyEl.value;
  if (d === 'easy') {
    ball.gravity = 420;
    pingInterval = 340;
    paddle.w = 200;
  } else if (d === 'normal') {
    ball.gravity = 600;
    pingInterval = 300;
    paddle.w = 160;
  } else {
    ball.gravity = 820;
    pingInterval = 240;
    paddle.w = 120;
  }
  paddle.w = paddle.w; // apply
}
let pingInterval = 300;
applyDifficulty();
difficultyEl.addEventListener('change', () => { applyDifficulty(); });

// user control
let pointerX = paddle.x + paddle.w/2;
function updatePaddleFromPointer() {
  const half = paddle.w/2;
  paddle.x = Math.max(10, Math.min(W - paddle.w - 10, pointerX - half));
}

// Pointer listeners
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  pointerX = e.clientX - rect.left;
  updatePaddleFromPointer();
});
canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  pointerX = e.touches[0].clientX - rect.left;
  updatePaddleFromPointer();
}, {passive:false});

// draw HUD & paddle (ball invisible unless reveal)
function draw() {
  ctx.clearRect(0,0,W,H);
  // background grid
  ctx.fillStyle = '#071a2a';
  ctx.fillRect(0,0,W,H);

  // ground strip
  ctx.fillStyle = '#092734';
  ctx.fillRect(0, groundY, W, H-groundY);

  // paddle
  ctx.fillStyle = '#ffd166';
  ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
  ctx.fillStyle = 'rgba(0,0,0,0.14)';
  ctx.fillRect(paddle.x, paddle.y + paddle.h, paddle.w, 4);

  // hint line (center)
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  ctx.fillRect(W/2 - 1, 0, 2, H);

  // optionally show invisible ball for cheat peek
  if (reveal) {
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,120,120,0.95)';
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fill();
  }

  // top guide text
  ctx.fillStyle = '#bcd7ee';
  ctx.font = '13px sans-serif';
  ctx.fillText('Paddle is visible ‚Äî ball is invisible. Use sound to find it!', 12, 20);
}

// physics update
let lastTime = null;
function step(ts) {
  if (!running) return;
  if (!lastTime) lastTime = ts;
  const dt = Math.min(0.05, (ts - lastTime)/1000); // prevent large jumps
  lastTime = ts;

  // integrate
  ball.vy += ball.gravity * dt;
  ball.x += ball.vx * dt;
  ball.y += ball.vy * dt;

  // wall bounce left/right
  if (ball.x - ball.r <= 0) { ball.x = ball.r; ball.vx = -ball.vx; playWallBounce(); }
  if (ball.x + ball.r >= W) { ball.x = W - ball.r; ball.vx = -ball.vx; playWallBounce(); }

  // top bounce
  if (ball.y - ball.r <= 0) { ball.y = ball.r; ball.vy = -Math.abs(ball.vy)*0.9; playWallBounce(); }

  // paddle collision detection: if ball crosses paddle top and within paddle horizontal range while falling
  if (ball.vy > 0 && (ball.y + ball.r) >= paddle.y && (ball.y - ball.r) <= paddle.y + paddle.h) {
    // check horizontal overlap
    if (ball.x >= paddle.x && ball.x <= paddle.x + paddle.w) {
      // reflect with small randomness based on hit position
      ball.y = paddle.y - ball.r - 0.5;
      ball.vy = -Math.abs(ball.vy) * (0.85 + Math.random() * 0.25);
      // tweak vx depending on where on paddle it hit (gives player control)
      const hitNorm = ((ball.x - paddle.x) / paddle.w) - 0.5; // -0.5 .. 0.5
      ball.vx += hitNorm * 450;
      bounces++;
      score += 10;
      playPop(true);
    }
  }

  // missed: ball hits ground
  if (ball.y - ball.r > H) {
    lives--;
    playMiss();
    if (lives <= 0) {
      endGame();
      return;
    } else {
      resetBallAfterMiss();
    }
  }

  // update UI & draw
  scoreEl.textContent = score;
  livesEl.textContent = lives;
  bouncesEl.textContent = bounces;
  roundEl.textContent = round;

  draw();
  requestAnimationFrame(step);
}

// game control
function startGame() {
  if (!audioCtx) initAudio();
  if (running) return;
  running = true;
  lastTime = null;
  startBtn.textContent = 'Restart';
  score = 0; lives = 3; bounces = 0; round = 1;
  resetBallToServe();
  schedulePing();
  requestAnimationFrame(step);
}
function pauseGame() {
  running = !running;
  if (!running) {
    // stop pings
    if (pingIntervalId) { clearInterval(pingIntervalId); pingIntervalId = null; }
    pauseBtn.textContent = 'Resume';
  } else {
    schedulePing();
    pauseBtn.textContent = 'Pause';
    lastTime = null;
    requestAnimationFrame(step);
  }
}
function endGame() {
  running = false;
  if (pingIntervalId) { clearInterval(pingIntervalId); pingIntervalId = null; }
  alert(`Game over! Score: ${score}, Bounces: ${bounces}`);
  // reset to initial visual
  resetBallToServe();
}
function resetBallToServe() {
  ball.x = W/2;
  ball.y = 110;
  ball.vx = (Math.random() > 0.5 ? 1 : -1) * (140 + Math.random()*120);
  ball.vy = 50 * (0.8 + Math.random()*0.6);
  draw();
}
function resetBallAfterMiss() {
  // brief pause and serve again
  running = false;
  if (pingIntervalId) { clearInterval(pingIntervalId); pingIntervalId = null; }
  setTimeout(() => {
    ball.x = W/2;
    ball.y = 80;
    ball.vx = (Math.random() > 0.5 ? 1 : -1) * (120 + Math.random()*120);
    ball.vy = 40 + Math.random()*80;
    running = true;
    schedulePing();
    lastTime = null;
    requestAnimationFrame(step);
  }, 700);
}

// audio system: ping based on ball position
function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // create a short noise buffer for pops
  const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
  const d = noiseBuf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = (Math.random()*2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 0.12));
  window._invisible_noise = noiseBuf; // reuse
}

// play a ping that hints at ball position
function playPingNow() {
  if (!audioCtx || muted) return;
  // derive stereo pan from ball.x (left -1 .. right 1)
  const pan = (ball.x / W) * 2 - 1;
  // derive pitch from vertical distance to ground (closer to paddle => higher freq)
  const distToPaddle = Math.max(0, paddle.y - ball.y); // >0 when ball is above paddle
  // map vertical to frequency: far -> low ~300Hz, close -> high ~1200Hz
  const freq = 300 + Math.max(0, 1 - (distToPaddle / (H))) * 900;
  const volume = Math.min(1, 0.12 + (1 - (ball.y / H)) * 0.9); // higher when ball higher (optional)
  playTone(freq, pan, volume, 0.09);
}

// schedule repeated ping
function schedulePing() {
  if (pingIntervalId) { clearInterval(pingIntervalId); pingIntervalId = null; }
  pingIntervalId = setInterval(playPingNow, pingInterval);
  // also play immediately
  playPingNow();
}

// play a short tone with panning and envelope
function playTone(freq, panVal, vol=0.5, dur=0.12) {
  if (!audioCtx || muted) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  const p = audioCtx.createStereoPanner();
  o.type = 'sine';
  o.frequency.value = Math.max(60, freq);

  p.pan.value = Math.max(-1, Math.min(1, panVal));
  g.gain.value = 0;
  o.connect(g);
  g.connect(p);
  p.connect(audioCtx.destination);

  const t0 = audioCtx.currentTime;
  g.gain.cancelScheduledValues(t0);
  g.gain.setValueAtTime(0, t0);
  g.gain.linearRampToValueAtTime(vol, t0 + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
  o.start(t0);
  o.stop(t0 + dur + 0.02);
}

// play pop (for bounce) or wall bounce
function playPop(isPaddleHit=false) {
  if (!audioCtx || muted) return;
  // use short noise burst
  const buf = window._invisible_noise;
  const source = audioCtx.createBufferSource();
  source.buffer = buf;
  const g = audioCtx.createGain();
  const p = audioCtx.createStereoPanner();

  // pan based on ball.x
  const pan = (ball.x / W) * 2 - 1;
  p.pan.value = pan;
  source.connect(g);
  g.connect(p);
  p.connect(audioCtx.destination);

  // envelope: strong for paddle hit, softer for wall
  const now = audioCtx.currentTime;
  g.gain.setValueAtTime(isPaddleHit ? 0.35 : 0.18, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + (isPaddleHit ? 0.22 : 0.18));
  source.start(now);
  source.stop(now + 0.23);
  // small click tone layered
  playTone(isPaddleHit ? 1200 : 600, pan, isPaddleHit ? 0.15 : 0.09, 0.06);
}

// wall bounce (soft)
function playWallBounce() {
  playTone(420, (ball.x / W) * 2 - 1, 0.06, 0.07);
}

// miss sound
function playMiss() {
  if (!audioCtx || muted) return;
  playTone(120, 0, 0.2, 0.4);
  // quick sad descending
  setTimeout(()=> playTone(220, 0, 0.12, 0.22), 80);
  setTimeout(()=> playTone(160, 0, 0.09, 0.28), 180);
}

// controls
startBtn.addEventListener('click', () => {
  if (!audioCtx) initAudio();
  startGame();
});
pauseBtn.addEventListener('click', pauseGame);
muteBtn.addEventListener('click', () => {
  muted = !muted;
  muteBtn.textContent = muted ? 'Unmute' : 'Mute';
});
revealBtn.addEventListener('click', () => {
  reveal = !reveal;
  revealBtn.textContent = reveal ? 'Hide Peek' : 'Peek (cheat)';
  draw();
});

// small helper to ensure audioContext is resumed after user gesture (some browsers require)
document.addEventListener('click', () => {
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
}, {once:false});

// initial drawing
draw();

// make sure audioContext is created on first interaction for autoplay policies
['mousedown','touchstart','keydown'].forEach(ev => {
  window.addEventListener(ev, () => {
    if (!audioCtx) {
      try { initAudio(); } catch(e) { console.warn('Audio init error', e); }
    }
  }, {once:true});
});
</script>
</body>
</html>
